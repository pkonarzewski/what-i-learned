
#%% PROBLEM 1
"""
PROBLEM 1
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
"""

# simple
def problem1_simple(n: int) -> int:
    result = 0

    for i in range(1, n):
        if i % 3 == 0 or i % 5 == 0:
            result += i
    return result

assert problem1_simple(10) == 23
print(problem1_simple(1000))


# functional approach
assert sum([x for x in range(1,10) if x % 3 == 0 or x % 5 == 0]) == 23
print(sum([x for x in range(1,10) if x % 3 == 0 or x % 5 == 0]))


# using geometric/arithmetic aproach sequence
def problem1_alternative(n, p):
    N = (p-1) // n
    return n*(N*(N+1)//2)

assert problem1_alternative(3, 10) + problem1_alternative(5, 10) - problem1_alternative(15, 10) == 23
print(problem1_alternative(3, 1000) + problem1_alternative(5, 1000) - problem1_alternative(15, 1000))


# BENCHMARK
bench_n = 100000
print('simple, complexity O(n)')
%timeit problem1_simple(bench_n)
print('functional, complexity O(n)')
%timeit sum([x for x in range(1, bench_n) if x % 3 == 0 or x % 5 == 0])
print('alternative, complexity O(1)')
%timeit problem1_alternative(3, bench_n) + problem1_alternative(5, bench_n) - problem1_alternative(15, bench_n)


#%% PROBLEM 2
"""
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.
"""

def fib_even(n: int) -> int:
    a, b = 1, 1
    fib_sum = 0
    while True:
        a, b = b, a + b  # variable swaping
        if b > n:
            break
        elif b % 2 == 0:
            fib_sum += b
    return fib_sum


assert fib_even(4000000) == 4613732


def fib_golden_ratio(n: int) -> int:
    """
    Phi (golden ratio) is the approximate ratio between
    two consecutive terms in a Fibonacci sequence.
    The ratio between consecutive even terms approaches
    phi^3 (4.236068) because each 3rd term is even.
    Use a calculator and round the results to the nearest
    integer when calculating the next terms:

    2,8,34,.. multiplying by 4.236068 each time: 144,610,
    2584,10946,46368,196418 & 832040
    """
    a = 2
    sum = 2
    phi = 4.236068

    while True:
        a = round(a*phi)
        if a < n:
            sum += a
        else:
            break
    return sum

assert fib_golden_ratio(4000000) == 4613732


# BENCHMARK
print('simple O(n)')
%timeit fib_even(1000000)
print('golden ratio O(n)')
%timeit fib_golden_ratio(1000000)


#%% PROBLEM 3
"""
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?
"""
from typing import List
from math import floor, sqrt, ceil

def is_prime(n: int) -> bool:
    if n < 2:
        return False
    else:
        for i in range(2, floor(sqrt(n)+1)):
            if n % i == 0:
                return False
        return True

def prime_number_simple(n: int) -> List[int]:
    primes = []
    prime_asymptot = floor(sqrt(n))

    for i in range(2, prime_asymptot + 1):
        if n  % i == 0:
            if is_prime(i):
                primes.append(i)

    return primes


print(prime_number_simple(13195))
assert max(prime_number_simple(13195)) == 29
print(prime_number_simple(600851475143))


%timeit prime_number_simple(600851475143)
#%% PROBLEM 4 - Largest palindrome product
"""
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.
"""

def palindrome_product(digits: int) -> int:
    min_number = 10**(digits - 1)
    max_number = 10**digits - 1
    max_product = 1

    for i in range(max_number, min_number - 1, -1):
        if i**2 > max_product:
            for j in range(i, min_number - 1, -1):
                prod = i * j
                if str(prod) == (str(prod))[::-1] and prod > max_product:
                    max_product = prod
                    break

    return max_product


print(palindrome_product(2))
print(palindrome_product(3))
print(palindrome_product(4))

assert palindrome_product(2) == 9009

%timeit palindrome_product(4)

#%%
def reverse_integer(number: int) -> int:
    """Test int reverse without casting to str."""

    digits = []
    new_digit = 0
    no_digits = 0

    while number > 0:
        dig = number % 10
        digits.append(dig)

        number //=10
        no_digits += 1

    reversed_number = 0
    for n in range(no_digits, 0, -1):
        reversed_number += digits[n]*10**n

    return reversed_number

print(reverse_integer(123))

#%% PROBLEM 5 - Smallest multiple
"""
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
"""

#%%
from generic import factorization, product_of_list
from math import factorial


def smallest_multiple_bruteforce(no_range: int) -> int:
    """Better? approach."""
    factors = []
    for i in range(1, no_range+1):
        factors.extend(factorization(i))
    lcm = product_of_list(set(factors))
    range_product = product_of_list([x for x in range(1, no_range + 1)])

    multi = 0
    result = None
    while True:
        multi += 1
        num = lcm * multi
        if num > range_product:
            break

        valid = True
        for n in range(2, no_range + 1):
            if num % n != 0:
                valid = False
                break
            result

        if valid:
            return num


assert smallest_multiple_bruteforce(10) == 2520
smallest_multiple_bruteforce(20)

%timeit smallest_multiple_bruteforce(40)

# %% PROBLEM 6 - Sum square difference
"""
The sum of the squares of the first ten natural numbers is 385,
The square of the sum of the first ten natural numbers is 3025,
Hence the difference between the sum of the squares of the first ten natural numbers
and the square of the sum is. Find the difference between the sum of the squares of the
first one hundred natural numbers and the square of the sum.
"""

def sum_square_diff(limit):
    "Brute force approach"
    sum_sqr = sum([x**2 for x in range(1, limit + 1)])
    sqr_sum = sum([x for x in range(1, limit + 1)])**2

    print(sum_sqr)

    return sqr_sum - sum_sqr


assert sum_square_diff(10) == 2640
print(sum_square_diff(100))

#%%
def sum_square_diff_2(n):
    """Using sequence formulas."""

    sqr_sum = ((1+n)*(n/2))**2
    sum_sqr = ((n * (n+1)) * (n + (n+1)))/6
    return sqr_sum - sum_sqr


assert sum_square_diff_2(10) == 2640
print(sum_square_diff_2(100))

# %% PROBLEM 7
"""
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th
prime is 13.
What is the 10 001st prime number?
"""
from generic import is_prime


def nth_prime(n):
    "Brute force."

    if n == 1:
        return 2
    else:
        value = 3
        nth = 2
        while nth < n:
            value += 2
            if is_prime(value):
                nth += 1

    return value


assert nth_prime(6) == 13
print(nth_prime(10001))

# %% PROBLEM 8 - Largest product in a series
"""
The four adjacent digits in the 1000-digit number that have the greatest product are
9 × 9 × 8 × 9 = 5832.
Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
What is the value of this product?
"""


def largest_product_in_series(number, series_len):

    if not isinstance(number, str):
        number = str(number)

    largest_series = None
    largest_product = 0

    for i in range(len(number)-series_len+1):
        series = number[i:i+series_len]

        if not '0' in series:
            prod = 1
            for d in series:
                prod *= int(d)

            if prod > largest_product:
                largest_series = series
                largest_product = prod

    # print('largest series', largest_series)
    return largest_product


number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

assert largest_product_in_series(number, 4) == 5832
print(largest_product_in_series(number, 13))

#%%
"My failed attempt to understand question, but it was fun anyway ;)"

def digits_adjecent(n1: int, n2: int) -> bool:
    return abs(n1 - n2) <= 1


def largest_product_in_series_fuu(number, series_len):


    if not isinstance(number, str):
        number = str(number)


    max_series = None
    max_seriers_product = 0

    cur_series = [int(number[0])]

    for i in range(1, len(number)):
        if digits_adjecent(int(number[i-1]), int(number[i])):
            cur_series.append(number[i])

        if not digits_adjecent(int(number[i-1]), int(number[i])) or i == len(number)-1:
            if len(cur_series) == series_len:
                prod = 1
                for n in cur_series:
                    prod *= int(n)
                if prod > max_seriers_product:
                    max_seriers_product = prod
                    max_series = cur_series

            # start new series
            cur_series = [number[i]]

    print(max_series)
    return max_seriers_product

number = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
assert largest_product_in_series_fuu(number, 4) == 5832
print(largest_product_in_series_fuu(number, 13))
# %% PROBLEM 9 - Special Pythagorean triplet
"""
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
a2 + b2 = c2
For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
"""


def pythagorean_triplet(c):
    return


print(pythagorean_triplet(25)) # == (3*4*5)
print(pythagorean_triplet(1000))
